# 클래스와 구조체

구조체와 클래스는 하나의 큰 코드 블록이다. 안에 변수 또는 상수를 넣어 값을 정의하거나, 함수를 넣어서 기능을 정의할 수도 있다. 스위프트는 객체지향 언어이기 때문에 구조체와 클래스는 문법 상 중요한 요소 중 하나이다.

* 프로퍼티(Properties) : 구조체와 클래스 내부의 변수와 상수
* 메서드(Method) : 구조체와 클래스 내부에서 정의된 함수
* 멤버(Member) : 프로퍼티와 메소드를 합하여 구조체나 클래스의 멤버라고 한다.

### 구조체 vs 클래스

* 공통점
  * 프로퍼티
  * 메소드
  * 서브스크립트 : 속성값에 접근할 수 있는 방법을 제공
  * 초기화 블록 : 객체를 원하는 초기 상태로 설정
  * 확장 : 객체에 함수적 기능을 추가하는 확장(extends) 구문 사용
  * 프로토콜 : 특정 형식의 함수적 표준을 제공
* 클래스만 할 수 있는 기능
  * 상속 : 클래스의 특성을 다른 클래스에게 물려줄 수 있다.
  * 타입 캐스팅 : 실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사할 수 있다.
  * 소멸화 구문 : 인스턴스가 소멸되기 직전에 처리해야 할 구문을 미리 등록할 수 있다.
  * 참조에 의한 전달 : 클래스 인스턴스가 전달될 때에는 참조 형식으로 제공되며, 이 때 참조가 가능한 개수는 제약이 없다.

## 기본 개념

### 정의

구조체와 클래스의 이름은 대문자로 시작한다. 명명 규칙에 따르도록 하자.

```swift
// 구조체
struct 구조체 이름 {
  // 정의 내용
}

// 클래스
class 클래스 이름 {
  // 정의 내용
}
```

### 메소드와 프로퍼티

선언된 값에 따라 타입 선언이 가능하다.

```swift
struct Resolution {
  var width = 0
  var height = 0
  
  func desc() -> String {
    return "Resolution 구조체"
  }
}

class VideoMode {
  var interlaced = false
  var frameRate = 0.0
  var name : String?
}
```

### 인스턴스

클래스와 구조체를 생성한 후 여러 개를 찍어내듯이 만들고 할당할 수 있다. 이 찍어낸 복사본과 같은 개념을 인스턴스라고 한다. 같은 건물의 설계도를 가지고 여러 개의 건물을 세우는 것과 유사한 방식이라고 보면 되겠다.

```swift
let g = guJoChae()

let c = makeClass()
```

```. (dot)```을 이용하여클래스와 구조체 내의 프로퍼티에 접근할 수 있다. 예를 들어 ```g.name```, ```c.width```와 같이 말이다. 

### 초기화

구조체나 클래스 뒤에 빈괄호를 붙이면 기본적인 인스턴스가 만들어진다. 때로는 파라미터를 괄호 속에 넣어주기도 하는데, 이를 초기화(Initialize)하기 위해 반드시 필요한 값들입니다.

구조체나 클래스를 초기화할 때는 매개변수의 값 역시 초기화가 필요하다.

```swift
let initTest = testMethod(a: 1, b: 2)
```

### 구조체의 값 전달 방식: 복사에 의한 전달

구조체와 클래스의 차이는 값 전달 방식이다. 구조체는 인스턴스를 생성한 후 이를 변수나 상수에 할당하거나 함수의 인자값으로 전달할 때 값을 복사하여 전달하는 방식이다. 이를 **값 타입(Value Type)**, 또는 **복사에 의한 전달**이라고 한다. 앞서 자료형은 모두 복사를 통해 값이 전달된다고 언급한 적이 있는데, 이는 자료형 자체가 실제로는 구조체로 구현되었기 때문이다.

구조체 인스턴스는 변수에 대입 시, 복사한 값으로 대입되는 것이다. 그러므로 기존 인스턴스와 대입된 인스턴스는 독립적이다. 한 쪽에서 변경이 되어도 다른 쪽에 영향을 주지 않는다.

### 클래스의 값 전달 방식 : 참조에 의한 전달

메모리 주소를 사용하여 객체 자체를 전달한다. 따로 주소값을 전달할 필요 없이, 객체 주소값만 넘긴다면, 자유롭게 사용이 가능하다. 클래스 초기화와 동시에 프로퍼티를 사용하는 것이 가능하다.

> 인스턴스 비교 연산자

```swift
// === : 동일 인스턴스인지 비교
// !== : 다른 인스턴스인지 비교
```

일반적으로 다음 조건에 하나 이상 해당한다면 구조체 사용을 권장한다.

1. 서로 연관된 몇 개의 기본 데이터 타입들을 캡슐화하여 묶는 것이 목적일 때
2. 캡슐화된 데이터에 상속이 필요하지 않을 때
3. 캡슐화된 데이터를 전달하거나 할당하는 과정에서 참조 방식보다는 값이 복사되는 것이 합리적일 때
4. 캡슐화된 원본 데이터를 보존해야 할 때

## 프로퍼티(Property)

클래스와 구조체를 구성하는 중요 요소이다. 프로퍼티는 값을 저장하기 위한 목적으로 클래스와 구조체 내에서 정의된 변수나 상수를 의미한다. 정확히는 **값을 제공**한다.

프로퍼티에는 저장 프로퍼티와 연산 프로퍼티가 있다.

* 저장 프로퍼티
  * 입력된 값을 저장, 저장된 값을 제공함
  * 상수 및 변수를 사용하여 정의가 가능함
  * 클래스와 구조체에서 사용이 가능하지만, 열거형에서는 사용할 수 없음

* 연산 프로퍼티
  * 특정 연산을 통해 값을 만들어 제공하는 역할
  * 변수만 사용해서 정의 가능함
  * 클래스, 구조체, 열거형 모두에서 사용 가능함

### 저장 프로퍼티

클래스 내에서 선언된 변수나 상수를 부르는 이름이다. 변수는 속성 변수이고, 상수는 속성 상수라고 한다. 저장 프로퍼티는 일반적인 변수, 상수를 초기화하듯이 초기화 값을 지정할 수 있다. 단, 필수는 아니다.

초기값을 할당하지 않으면 유의해야 할 점들이 있다. 초기값이 할당되지 않은 저장 프로퍼티는 반드시 옵셔널 타입으로 선언해야 한다. 클래스의 프로퍼티에 값이 비어있다면 인스턴스를 생성할 때 무조건 nil로 초기화한다. 물론 처음부터 값 할당을 하면 옵셔널로 할 필요가 없다.

초기값을 주지 않으면서 옵셔널 타입으로 선언하지 않을 수 있는 방법도 존재한다. ***초기화구문에서 프로퍼티의 값을 초기화하는 것이다.*** 클래스 프로퍼티는 인스턴스를 생성할 때 초기화하기 때문에 프로퍼티 초기값은 인스턴스를 생성하기 전까지만 할당하면 된다. 초기화 구문에서 프로퍼티 값 할당이 가능하다면 옵셔널로 선언하지 않아도 된다.

```swift
class User {
	var name : String
	// 클래스 프로퍼티의 초기값 설정이 안되어서 Error
}
```

```swift
/* 올바른 예시 */
class User {
	var name : String
	
	init() {
		self.name = ""
	}
}
```

```swift
class User {
// 옵셔널의 예시
	var name : String?
	// var name : String! 도 가능.
}
```

```swift
class User {
	// 아예 초기화하는 방법
	var name : String = ""
}
```

> 저장 프로퍼티의 분류

- var 키워드로 정의되느 변수형 저장 프로퍼티(멤버 변수)
- let 키워드로 정의되는 상수형 저장 프로퍼티(멤버 상수)

```swift
// 구조체의 저장 프로퍼티

struct guJoChae1 {
	var intValue1 : Int
	let intValue2 : Int
}

struct guJoChae2 {
	let intValue3 : Int
	var intValue4 : Int
}
```

> 지연 저장 프로퍼티

저장 프로퍼티는 클래스 인스턴스가 생성될 때 함께 초기화되지만, lazy키워드가 있다면 예외가 된다. 키워드 이름처럼 초기화를 지연시키는 역할을 한다. 프로퍼티가 호출되는 순간에 초기화된다.

```swift
class OnCreate {
	init() {
		print("OnCreate")
	}
}

class LazyTest {
	var base = 0
	lazy var late = OnCreate()
	
	init() {
		print("Lazy Last")
	}
}
```

> 클로저를 이용한 저장 프로퍼티 초기화

```swift
// 프로퍼티 참조 시에 최초 한 번만 실행한다.
let/var 프로퍼티명: 타입 = {
	정의 내용
	return 리턴값
}()
```

### 연산 프로퍼티

저장 프로퍼티와는 다르게 다른 프로퍼티의 값을 연산 처리하여 간접적으로 값을 제공한다. 프로퍼티의 값을 참조하기 위해 구문이 ```get```구문이다.

```set``` 구문을 추가할 수 있다. 값을 할당하거나 변경할 때 실행된다. set 구문은 필요에 따라 생략이 가능하다.

```swift
class/struct/enum 객체명 {
	var 프로퍼티명 : 타입 {
		get {
			//......
			return 리턴값
		}
		
		set ( 매개변수 ) {
			//......
		}
	}
}
```

다음은 진짜 예시이다.

```swift
import Foundation

// 나이 계산
struct UserInfo {
	var birth : Int!
	
	var thisYear : Int {
		get {
			let df = DateFormatter()
			df.dateFormat = "yyyy"
			return Int(df.string(from: Date()))
		}
		
		var age : Int {
			get {
				return (self.thisYear - self.birth) + 1
			}
		}
	}
}

let info = UserInfo(birth: 1990)
print(info.age)

// 28
```

### 프로퍼티 옵저버

특정 프로퍼티를 관찰하다가 값 등이 변경되면 이에 반응한다. 직접 변경, 자동 변경 모두 반응하여 호출된다. 동일한 값이 재할당되어도 마찬가지이다.

* willSet : 프로퍼티의 값이 변경되기 직전 호출되는 옵저버
* didSet : 프퍼티의 값이 변경된 직후 호출되는 옵저버

```swift
// willSet 옵저버

var <프로퍼티명> : <타입> [ = <초기값> ] {
	willSet [ (<인자명>) ] {
		<프로퍼티 값이 변경되기 전에 실행할 내용>
	}
}
```

```swift
// didSet

var <프로퍼티명> : <타입> [ = <초기값> ] {
	didSet [ (<인자명>) ] {
		<프로퍼티 값이 변경된 후에 실행할 내용>
	}
}
```

### 타입 프로퍼티

